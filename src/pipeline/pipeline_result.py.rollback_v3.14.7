# ============================================================
#  ARCHITECTURAL PATCH: PIPELINE_RESULT_REWRITE_v3.14.7
#  TARGET FILE:
#     D:\StoicizmFrame_v3.14_clean\src\pipeline\pipeline_result.py
#
#  PURPOSE:
#     Расширенный PipelineResult:
#     - scene/version/paths (структура C)
#     - donor_file + QC-статус + QC-сообщения
#     - pending-механизм
#     Полная совместимость с PipelineLogger и планом v3.6.
# ============================================================

from pathlib import Path
from datetime import datetime


class PipelineResult:
    """Результат работы фабрики StoicizmFrame: сцена, версия, статус, артефакты, QC и донор."""

    def __init__(
        self,
        scene_id,
        version,
        version_dir,
        status,
        donor_file: str | None = None,
        qc_status: str | None = None,
        qc_messages: list[str] | None = None,
    ):
        self.scene_id = scene_id
        self.version = version
        self.version_dir = Path(version_dir)
        self.status = status
        self.timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Донор (может быть None, если запускаем не из файла)
        self.donor_file = donor_file

        # QC-информация (финальный статус и сообщения)
        self.qc_status = qc_status if qc_status is not None else status
        self.qc_messages = qc_messages if qc_messages is not None else []

        # Pending-механизм
        self.pending_reason: str | None = None

        # Пути структуры C
        self.scenario_path = self.version_dir / "scenario" / "scenario.json"
        self.qc_path = self.version_dir / "qc" / "qc.json"
        self.prepublish_path = self.version_dir / "qc" / "prepublish.json"
        self.audio_dir = self.version_dir / "audio"
        self.video_dir = self.version_dir / "video"
        self.reports_dir = self.version_dir / "reports"

    # -----------------------------
    #  Pending API
    # -----------------------------
    def is_pending(self) -> bool:
        return self.status == "PENDING"

    def mark_pending(self, reason: str):
        self.status = "PENDING"
        self.pending_reason = reason

    # -----------------------------
    #  Serialization
    # -----------------------------
    def to_dict(self):
        return {
            "scene_id": self.scene_id,
            "version": self.version,
            "status": self.status,
            "timestamp": self.timestamp,
            "donor_file": self.donor_file,
            "qc": {
                "status": self.qc_status,
                "messages": self.qc_messages,
                "pending_reason": self.pending_reason,
            },
            "paths": {
                "scenario": str(self.scenario_path),
                "qc": str(self.qc_path),
                "prepublish": str(self.prepublish_path),
                "audio": str(self.audio_dir),
                "video": str(self.video_dir),
                "reports": str(self.reports_dir),
            },
        }

    def to_markdown(self):
        """Кинематографический отчёт о сцене."""
        lines = [
            f"## {self.scene_id} — {self.version}",
            f"### Статус: {self.status}",
            "",
            "---",
            "",
            "### Донор",
            self.donor_file or "— (запуск без явного донор-файла)",
            "",
            "### QC",
            f"- Итоговый статус QC: {self.qc_status}",
            f"- Сообщений QC: {len(self.qc_messages)}",
            "",
            "### Артефакты",
            f"- Сценарий: {self.scenario_path}",
            f"- QC: {self.qc_path}",
            f"- PrePublish: {self.prepublish_path}",
            f"- Аудио: {self.audio_dir}",
            f"- Видео: {self.video_dir}",
            f"- Отчёты: {self.reports_dir}",
            "",
            "---",
            "",
            "### Pending",
            f"- В pending: {self.is_pending()}",
            f"- Причина: {self.pending_reason or '—'}",
            "",
            "### Метка времени",
            self.timestamp,
        ]
        return "\n".join(lines)


"""
ROLLBACK: pipeline_result.py.rollback_before_scene_versioning
"""
